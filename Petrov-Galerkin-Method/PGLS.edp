
// Transporte de calor em uma cavidade quadrada unitária
// Utilizando métodos com P1-P1-P1
// Estabilização via PGLS

func real[int] runSimulation(int n) {

    // Malha 
      border a1(t=0,1){x=t; y=0; label=2;}
      border a2(t=0,1){x=1; y=t; label=2;}
      border a3(t=0,1){x=1-t; y=1; label=1;}
      border a4(t=0,1){x=0; y=1-t; label=2;}
      mesh Th = buildmesh(a1(n)+a2(n)+a3(n)+a4(n));

    // Espaços 
      fespace Vh(Th, P1);
      fespace Qh(Th, P1);
      fespace ThT(Th, P1);
      fespace Ht(Th, P0);

      Vh u1, u2, u1old, u2old, v1, v2 ;
      Qh p, q;
      Vh du1, du2;
      ThT T, Told, theta;
      Ht ht;

    // Parâmetros 
      real Re = 400;        // Reynolds
      real Pe = 10^6;       // Peclet
      real nu = 1.0/Re;     // Viscosidade
      real dt = 1e-5;       // Passo de tempo
      int  nmax = 1;        // Passos de tempo
      int  itmax = 20;      // Iterações de Picard
      real kappa = 1.0/Pe;  // Condutividade
      real pi = acos(-1);

    // Solução exata  
    Vh u1exact = 10*x^2*(x-1)^2*(y-1)*(2*y-1)*cos(dt);
    Vh u2exact =  -10*x*y^2*(x-1)*(2*x-1)*(y-1)*cos(dt) ;
    Qh pexact = 10*(2*x-1)*(2*y-1)*cos(dt);  
    ThT Texact = 10*x^2*(x-1)^2*y^2*(y-1)^2*sin(dt); 

    // Inicialização 
    u1old = u1exact;
    u2old = u2exact;
    Told  = Texact;

    // --- Fonte ---
    func fxfunc = -sin(dt) * ( 10*x^2*(x-1)^2*(y-1)*(2*y-1) )
      + (cos(dt))^2 * (100*(2*x^4 - 4*x^3 + 2*x^2)*(4*x^3 - 6*x^2 + 2*x)*(2*y^2 - 3*y + 1)^2
      - 100*(2*x^3 - 3*x^2 + x)*(y^3 - y^2)*(2*x^4 - 4*x^3 + 2*x^2)*(4*y - 3))
      + cos(dt) * ( 20*(2*y - 1) )
      - nu*cos(dt) * ((120*x^2 - 120*x + 20)*(2*y^2 - 3*y + 1)
      + (2*x^4 - 4*x^3 + 2*x^2)*4
      );

    func fyfunc = -sin(dt) * ( -10*x*y^2*(x-1)*(2*x-1)*(y-1) )
      + (cos(dt))^2 * (-100*(2*x^4 - 4*x^3 + 2*x^2)*(2*y^2 - 3*y + 1)*(6*x^2 - 6*x + 1)*(y^3 - y^2)
      +100*(2*x^3 - 3*x^2 + x)^2*(y^3 - y^2)*(3*y^2 - 2*y) )
      + cos(dt) * ( 20*(2*x - 1) ) - nu*cos(dt) * (-(120*x^2 - 120*x + 20)*(y^3 - y^2)
      - (2*x^3 - 3*x^2 + x)*(6*y - 2)
      );

    func sfunc = 10 * cos(dt) * (2*x^3 - 3*x^2 + x) * (y^2 - 4*y + 2);

    func fTfunc =  10*x^2*(x-1)^2*y^2*(y-1)^2*cos(dt)
        + u1exact * dx(Texact) + u2exact * dy(Texact)
        - kappa * (dxx(Texact) + dyy(Texact));

    // Estabilização 
    real lambda = 0.5;      

    // macros 
      macro ht()      1/n //
      macro umod() sqrt(u1old^2 + u2old^2 + 1e-8) //
      macro Pek()     (((1./12)*umod*ht)/(2.0*(kappa))) //
      macro ReK()   (((1./12)*umod*ht)/(4*(nu))) //
      macro xi(pe)   ( ((pe) < 1.0 ? (pe) : 1.0 )) //
      macro tau()  ( (ht/(2*umod) * xi(ReK))) //
      // macro tau() (1.0e-4 / (sqrt ((2/dt)^2 + (2.0*umod/ht)^2 + (4.0*nu/ht^2)^2))) //
      // macro tauT() ( ht/(2*umod) * xi(Pek)) //
      macro tauT()  (((1./12) * ht^2)/(4*kappa)) //
      macro delta() ( lambda *umod* ht*xi(ReK) ) //

    // auxiliares 
    Vh u1DivDt = u1/dt, u2DivDt = u2/dt;
    Vh u1oldDivDt = u1old/dt, u2oldDivDt = u2old/dt;
    ThT TDivDT = T/dt, ToldDivDt = Told/dt;

    // ---- Loop no tempo ----
    for (int nTimeStep = 0; nTimeStep < nmax; ++nTimeStep) {
        cout << "\n>>> Passo = " << nTimeStep << ", t = " << nTimeStep*dt << ", n = " << n << endl;

          problem NSE([u1, u2, p], [v1, v2, q]) =
                  int2d(Th)(
                      // Galerkin padrão
                    (1./dt) * (u1*v1 + u2*v2)
                    + nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1) + dx(u2)*dx(v2) + dy(u2)*dy(v2))
                    + u1old*dx(u1)*v1 + u2old*dy(u1)*v1
                    + u1old*dx(u2)*v2 + u2old*dy(u2)*v2
                    - 1e-6*p*q
                    - p*(dx(v1) + dy(v2)) 
                  )
                - int2d(Th)( q*( dx(u1) + dy(u2) ) )   
                + int2d(Th)( q * sfunc )               
                - int2d(Th)((1.0/dt)*(u1old*v1 + u2old*v2))
                - int2d(Th)( fxfunc * v1 + fyfunc * v2 )

                // primeira parte (u.grad(v) ∗ (du_t + u.grad(u) + grad(p) − nu∗lap(u) - f))
                + int2d(Th)((tau) * (
                          (u1DivDt - u1oldDivDt)*u1old*dx(v1) + (u2DivDt-u2oldDivDt)*u2old*dy(v2)
                        + (u1DivDt-u1oldDivDt)*u2old*dy(v1) + (u2DivDt-u2oldDivDt)*u1old*dx(v2)
                    ))
                + int2d(Th)
                  ( (tau) * (u1old*dx(v1) + u2old*dy(v1))*(u1old*dx(u1)+u2old*dy(u1)) + 
                  (u1old*dx(v2) + u2old*dy(v2))*(u1old*dx(u2)+u2old*dy(u2)))
                
                + int2d(Th)
                  ( tau*(dx(p)*(u1old*dx(v1)) + dy(p)*(u1old*dx(v2)) +
                    dx(p)*(u2old*dx(v1)) + dy(p)*(u2old*dy(v2))))
                - int2d(Th)(
                  (tau)*nu * ((dxx(u1)+dyy(u1))*(u1old*dx(v1) + u2old*dx(v1)) + (dxx(u2)+dyy(u2))*(u1old*dx(v2) + u2old*dx(v2))))

                -int2d(Th)(tau*((fxfunc*(u1old*(dx(v1) + dx(v2))) + fyfunc*u2old*(dy(v1) + dy(v2)))))

                //segunda parte (grad(q) ∗ (du_t + u.grad(u) + grad(p) −nu∗lap(u) - f))              
                + int2d(Th)((tau) * (
                          (u1DivDt-u1oldDivDt)*dx(q) + (u2DivDt-u2oldDivDt)*dy(q)
                    ))               
                + int2d(Th)
                  ( tau*(dx(q)*(u1old*dx(u1)) + dy(q)*(u1old*dx(u2)) +
                    dx(q)*(u2old*dx(u1)) + dy(q)*(u2old*dy(u2))))
                    
                + int2d(Th)
                  ( tau*(dx(p)*dx(q) + dy(p)*dy(q))
                )
                - int2d(Th)(
                  tau*nu * (dx(q)*(dxx(u1) + dyy(u1)) + dy(q)*(dxx(u2) + dyy(u2))))
                - int2d(Th)(
                  tau* (fxfunc*dx(q) + fyfunc*dy(q))
                )                  

                // terceira parte (−nu∗lap(v) ∗(du_t + u.grad(u) + grad(p) − nu∗lap(u) - f))
                + int2d(Th)((tau) * (
                          (u1DivDt)*nu*( (dxx(v1)+dyy(v1)) + u2DivDt*nu*( (dxx(v2)+dyy(v2)))))
  
                    )
                - int2d(Th)(
                    (tau) * (
                          u1oldDivDt*nu*( (dxx(v1)+dyy(v1))) + u2oldDivDt*nu*( (dxx(v2)+dyy(v2)))
                    )
                  )                
                + int2d(Th)
                  ( tau*nu*( (dxx(v1)+dyy(v1))*( u1old*dx(u1)+u2old*dy(u1)) +
                    (dxx(v2)+dyy(v2))*( u1old*dx(u2)+u2old*dy(u2)))
                    )
                + int2d(Th)
                  ( tau*nu*( (dxx(v1)+dyy(v1))*(dx(p)) +
                    (dxx(v2)+dyy(v2))*(dy(p)))
                  )
                - int2d(Th)
                  ( tau*nu*nu*((dxx(v1)+dyy(v1))*(dxx(u1)+dyy(u1)) +
                    (dxx(v2)+dyy(v2))*(dxx(u2)+dyy(u2)))
                  )
                - int2d(Th)(
                  tau* ((fxfunc*nu*(dxx(v1)+dyy(v1)) + fyfunc*nu*(dxx(v2)+dyy(v2))))
                )

              //Continuidade
              + int2d(Th)( delta * (dx(u1)+dy(u2)) * (dx(v1)+dy(v2)) )
              + on(1,2, u1 = u1exact, u2 = u2exact)
                ;

            for (int it=0; it<itmax; ++it) {
                cout << "   Picard it = " << it << endl;
                NSE;        

                // atualiza para próximo passo
                u1old = u1; u2old = u2;
            }

          solve heat(T,theta) =
              int2d(Th)(
                  (T/dt)*theta
               + (u1old*dx(T) + u2old*dy(T))*theta
              + kappa*(dx(T)*dx(theta) + dy(T)*dy(theta)))        
            - int2d(Th)((Told/dt)*theta)
            - int2d(Th)( fTfunc * theta )

            // Primeira parte (u*grad(theta)* (dT_t + u*gradT - kappa*lapT - fT )
            + int2d(Th)(tauT*((u1old*dx(theta) + u2old*dy(theta))* (TDivDT - ToldDivDt)))
            + int2d(Th)( tauT * ( u1old*dx(theta)*u1old*dx(T)  + u1old*u2old*dx(theta)*dy(T) 
                        + u2old*u1old*dy(theta)*dx(T) + u2old*u2old*dy(theta)*dy(T)))
            - int2d(Th)((tauT)*kappa * (( u1old*dx(theta) + u2old*dy(theta) ) * ( dxx(T) + dyy(T) ) ))  
            - int2d(Th)(tauT * fTfunc*(u1old*dx(theta) + u2old*dy(theta)))

            // Segunda parte (kappa*lap(theta)* (dT_t + u*gradT - kappa*lapT - fT )
            - int2d(Th)(tauT*kappa*((dxx(theta) + dyy(theta))* (TDivDT - ToldDivDt)))
            - int2d(Th)(tauT*kappa*((dxx(theta) + dyy(theta))*u1old*dx(T) + (dxx(theta) + dyy(theta))*u2old*dy(T)))
            + int2d(Th)(tauT*kappa*kappa*((dxx(theta) + dyy(theta))*(dxx(T) + dyy(T))))
            + int2d(Th)(tauT * kappa* fTfunc*(dxx(theta) + dyy(theta)))      
            + on(1, 2, T=Texact);

          cout << "meanTauT=" << int2d(Th)(tauT(u1old,u2old))/int2d(Th)(1.0) << endl;

  

      // plot ([u1,u2], fill=1, wait=0);
      // plot (p, fill=1, wait = 0);
      //plot (T, fill=1, wait = 0);

    }    
      // Cálculo das Normas L2 
      real L2u1 = sqrt(int2d(Th)((u1 - u1exact)^2));
      real L2u2 = sqrt(int2d(Th)((u2 - u2exact)^2));
      real L2p = sqrt(int2d(Th)((p - pexact)^2));
      real L2T = sqrt(int2d(Th)((T - Texact)^2));
      real L2u = sqrt(int2d(Th)((u1 - u1exact)^2 + (u2 - u2exact)^2));

      // Cálculo das Normas H1
      Vh eu1 = u1 - u1exact;
      Vh eu2 = u2 - u2exact;
      Vh eu = sqrt(eu1^2 + eu2^2);
      Vh epV = p - pexact;
      Vh eT = T - Texact;


      real H1uTotal = sqrt(int2d(Th)(eu1^2 + eu2^2 + dx(eu1)^2 + dy(eu1)^2 + dx(eu2)^2 + dy(eu2)^2 ));
      real H1pNorm = sqrt( int2d(Th)( epV^2 + dx(epV)^2 + dy(epV)^2 ) );
      real H1TNorm = sqrt( int2d(Th)( (eT)^2 + dx(eT)^2 + dy(eT)^2 ) );


      real[int] erros(6);
      erros[0] = L2u;
      erros[1] = H1uTotal;
      erros[2] = L2p;
      erros[3] = H1pNorm;
      erros[4] = L2T;
      erros[5] = H1TNorm;

      cout << "DEBUG n="<< n <<" h="<< 1.0/n 
          << " L2u="<<L2u << " L2u1="<<L2u1 << " L2u2="<<L2u2
          << " H1u="<<H1uTotal
          << " L2p="<<L2p << " H1p="<<H1pNorm
          << " L2T="<<L2T << " H1T="<<H1TNorm << endl;
      return erros;
}

  // Convergência + CSV 
    int[int] Ns = [8,16, 32, 64, 128];
    real[int] hs(Ns.n);
    real[int] L2u(Ns.n), H1u(Ns.n), L2p(Ns.n), H1p(Ns.n), L2T(Ns.n), H1T(Ns.n);
    real[int] ordemL2u(Ns.n), ordemH1u(Ns.n), ordemL2p(Ns.n), ordemH1p(Ns.n), ordemL2T(Ns.n), ordemH1T(Ns.n);

    for (int i=0;i<Ns.n;i++){
        int n = Ns[i];
        real h = 1.0/n; hs[i]=h;
        real[int] e = runSimulation(n);
        L2u[i]=e[0]; H1u[i]=e[1]; L2p[i]=e[2]; H1p[i]=e[3]; L2T[i]=e[4]; H1T[i]=e[5];
        if(i==0){ordemL2u[i]=ordemH1u[i]=ordemL2p[i]=ordemH1p[i]=ordemL2T[i]=ordemH1T[i]=0;}
        else{
            ordemL2u[i]=log(L2u[i]/L2u[i-1])/log(hs[i]/hs[i-1]);
            ordemH1u[i]=log(H1u[i]/H1u[i-1])/log(hs[i]/hs[i-1]);
            ordemL2p[i]=log(L2p[i]/L2p[i-1])/log(hs[i]/hs[i-1]);
            ordemH1p[i]=log(H1p[i]/H1p[i-1])/log(hs[i]/hs[i-1]);
            ordemL2T[i]=log(L2T[i]/L2T[i-1])/log(hs[i]/hs[i-1]);
            ordemH1T[i]=log(H1T[i]/H1T[i-1])/log(hs[i]/hs[i-1]);
        }
    }

    ofstream fout("tabela_erros.csv");
    fout << "h,L2u,Ordem_L2u,H1u,Ordem_H1u,L2p,Ordem_L2p,H1p,Ordem_H1p,L2T,Ordem_L2T,H1T,Ordem_H1T\n";
    for (int i=0;i<Ns.n;i++){
        fout << hs[i] << ","
            << L2u[i] << "," << (i==0?"NaN":ordemL2u[i]) << ","
            << H1u[i] << "," << (i==0?"NaN":ordemH1u[i]) << ","
            << L2p[i] << "," << (i==0?"NaN":ordemL2p[i]) << ","
            << H1p[i] << "," << (i==0?"NaN":ordemH1p[i]) << ","
            << L2T[i] << "," << (i==0?"NaN":ordemL2T[i]) << ","
            << H1T[i] << "," << (i==0?"NaN":ordemH1T[i]) << "\n";
    }
